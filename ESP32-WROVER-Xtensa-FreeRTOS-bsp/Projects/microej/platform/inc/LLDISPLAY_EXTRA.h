/* 
 * Copyright 2015-2019 MicroEJ Corp. All rights reserved.
 * MicroEJ Corp. PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/* 
 * AUTOGENERATED by Unknown product - Unknown version - DO NOT EDIT IT
 */
/**
 * Additional API to implement in order to use the hardware capacities.
 * Otherwise a weak implementation is taken in consideration.
 */
#ifndef _LLDISPLAY_EXTRA
#define _LLDISPLAY_EXTRA 
#include <intern/LLDISPLAY_EXTRA.h>
#include <stdint.h>
#ifdef __cplusplus
	extern "C" {
#endif
// --------------------------------------------------------------------------------
// -                                  Constants                                   -
// --------------------------------------------------------------------------------

/**
 * Returned value when function call has succeeded.
 */
#define LLDISPLAY_EXTRA_OK (0)

/**
 * Returned value when feature is not supported.
 */
#define LLDISPLAY_EXTRA_NOT_SUPPORTED (-9)

/**
 * Returned value when an out of memory has occured.
 */
#define LLDISPLAY_EXTRA_OUT_OF_MEMORY (-2)

/**
 * Return value when drawing is complete
 * @see LLDISPLAY_EXTRA_fillRect
 * @see LLDISPLAY_EXTRA_drawImage
 */
#define LLDISPLAY_EXTRA_DRAWING_COMPLETE (0)

/**
 * Return value when drawing is running (asynchronous)
 * @see LLDISPLAY_EXTRA_fillRect
 * @see LLDISPLAY_EXTRA_drawImage
 */
#define LLDISPLAY_EXTRA_DRAWING_RUNNING (1)

/**
 * Define the default format. Used when decoding an image without specifying
 * the output format. The implementation should select the better format.
 */
#define LLDISPLAY_EXTRA_IMAGE_DEFAULT (-1)

/**
 * Define an image with the same pixel representation and layout than the 
 * display memory.
 */
#define LLDISPLAY_EXTRA_IMAGE_LCD (0)

/**
 * Define an image whose pixel format is ARGB8888.
 */
#define LLDISPLAY_EXTRA_IMAGE_ARGB8888 (2)

/**
 * Define an image whose pixel format is RGB888.
 */
#define LLDISPLAY_EXTRA_IMAGE_RGB888 (3)

/**
 * Define an image whose pixel format is RGB565.
 */
#define LLDISPLAY_EXTRA_IMAGE_RGB565 (4)

/**
 * Define an image whose pixel format is ARGB1555.
 */
#define LLDISPLAY_EXTRA_IMAGE_ARGB1555 (5)

/**
 * Define an image whose pixel format is ARGB4444.
 */
#define LLDISPLAY_EXTRA_IMAGE_ARGB4444 (6)

/**
 * Define an image whose pixel format is Alpha1.
 */
#define LLDISPLAY_EXTRA_IMAGE_A1 (12)

/**
 * Define an image whose pixel format is Alpha2.
 */
#define LLDISPLAY_EXTRA_IMAGE_A2 (11)

/**
 * Define an image whose pixel format is Alpha4.
 */
#define LLDISPLAY_EXTRA_IMAGE_A4 (7)

/**
 * Define an image whose pixel format is Alpha8.
 */
#define LLDISPLAY_EXTRA_IMAGE_A8 (8)

/**
 * Define an image whose pixel format is Color1.
 */
#define LLDISPLAY_EXTRA_IMAGE_C1 (15)

/**
 * Define an image whose pixel format is Color2.
 */
#define LLDISPLAY_EXTRA_IMAGE_C2 (14)

/**
 * Define an image whose pixel format is Color4.
 */
#define LLDISPLAY_EXTRA_IMAGE_C4 (13)

/**
 * Define an image whose pixel format is Alpha1-Color1.
 */
#define LLDISPLAY_EXTRA_IMAGE_AC11 (18)

/**
 * Define an image whose pixel format is Alpha2-Color2.
 */
#define LLDISPLAY_EXTRA_IMAGE_AC22 (17)

/**
 * Define an image whose pixel format is Alpha4-Color4.
 */
#define LLDISPLAY_EXTRA_IMAGE_AC44 (16)

/**
 * Define an image whose pixel format is a LUT entry on 8 bits and target an
 * ARGB8888 color.
 */
#define LLDISPLAY_EXTRA_IMAGE_LARGB8888 (10)

/**
 * Define an image whose pixel format is a LUT entry on 8 bits and target a
 * RGB888 color.
 */
#define LLDISPLAY_EXTRA_IMAGE_LRGB888 (9)

/**
 * Define the flip mode "none": no flip must be performed<br>
 * The image<br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_NONE (0)

/**
 * Define the flip mode 90°: image must be rotated to 90° anticlockwise<br>
 * The image<br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * B D F<br>
 * A C E<br>
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_90 (7)

/**
 * Define the flip mode 180°: image must be rotated to 180° anticlockwise<br>
 * The image<br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * F E<br>
 * D C<br>
 * B A<br>
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_180 (4)

/**
 * Define the flip mode 270°: image must be rotated to 270° anticlockwise<br>
 * The image<br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * E C A<br>
 * F D B<br>
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_270 (2)

/**
 * Define the flip mode mirror + "none": only a vertical mirror must be applied.<br>
 * The image<br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * B A<br>
 * D C<br>
 * F E<br>
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_MIRROR (3)

/**
 * Define the flip mode mirror + 90°: a vertical mirror must be applied and then
 * the image must be rotated to 90° anticlockwise <br>
 * The image<br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * A C E<br>
 * B D F<br>
 * and then mirrored
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_MIRROR_90 (1)

/**
 * Define the flip mode mirror + 180°: a vertical mirror must be applied and then
 * the image must be rotated to 180° anticlockwise <br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * E F<br>
 * C D<br>
 * A B<br>
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_MIRROR_180 (6)

/**
 * Define the flip mode mirror + 270°: a vertical mirror must be applied and then
 * the image must be rotated to 270° anticlockwise <br>
 * <br>
 * A B<br>
 * C D<br>
 * E F<br>
 * <br>
 * is drawn:<br>
 * <br>
 * F D B<br>
 * E C A<br>
 * @see LLDISPLAY_EXTRA_flipImage
 */
#define LLDISPLAY_EXTRA_FLIP_MIRROR_270 (5)

// --------------------------------------------------------------------------------
// -                      Functions provided by the platform                      -
// --------------------------------------------------------------------------------

/**
 * The display graphics buffer may require more than memory than theorical memory.
 * Theorical memory size is <code>display width * display height * bpp / 8</code>. 
 * On some devices the memory width (in pixels) is higher than virtual width. 
 * In this way, the graphics buffer memory size is <code>memory width * height * bpp / 8</code>. 
 * This API allows to retrieve the memory width. Default behavior returns
 * display width.
 * @return the memory width (in pixels)
 */
int32_t LLDISPLAY_EXTRA_getGraphicsBufferMemoryWidth(void);

/**
 * @see LLDISPLAY_EXTRA_getGraphicsBufferMemoryWidth
 * @return the memory height (in pixels)
 */
int32_t LLDISPLAY_EXTRA_getGraphicsBufferMemoryHeight(void);

/**
 * Sets the new contrast. By default the weak function does nothing
 * (feature not supported).
 * @param contrast a value between <code>0</code> and <code>100</code>
 */
void LLDISPLAY_EXTRA_setContrast(int32_t contrast);

/**
 * Gets the current contrast. By default the weak function returns
 * <code>0</code>.
 * @return a value between code>0</code> and <code>100</code>
 */
int32_t LLDISPLAY_EXTRA_getContrast(void);

/**
 * Returns {@link LLDISPLAY_EXTRA_OK} when the display module can 
 * manage the display backlight or {@link LLDISPLAY_EXTRA_NOT_SUPPORTED}
 * otherwise. By default the weak function returns {@link LLDISPLAY_EXTRA_NOT_SUPPORTED}
 * (feature not supported).
 * @return {@link LLDISPLAY_EXTRA_OK} or {@link LLDISPLAY_EXTRA_NOT_SUPPORTED}
 */
int32_t LLDISPLAY_EXTRA_hasBackLight(void);

/**
 * Sets the new backlight value. By default the weak function does nothing
 * (feature not supported).
 * @param backlight a value between code>0</code> and <code>100</code>
 */
void LLDISPLAY_EXTRA_setBacklight(int32_t backLight);

/**
 * Gets the current backlight value. By default the weak function returns
 * <code>0</code>.
 * @return a value between code>0</code> and <code>100</code>
 */
int32_t LLDISPLAY_EXTRA_getBacklight(void);

/**
 * Turns on the backlight. By default the weak function does nothing
 * (feature not supported).
 */
void LLDISPLAY_EXTRA_backlightOn(void);

/**
 * Turns off the backlight. By default the weak function does nothing
 * (feature not supported).
 */
void LLDISPLAY_EXTRA_backlightOff(void);

/**
 * Asks if the diplay is a colored display or not. 
 * @return {@link LLDISPLAY_EXTRA_OK} when the display is not a grayscale display, 
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} otherwise. By default the weak function returns
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when the BPP is lower than or equals to 4 BPP and 
 * {@link LLDISPLAY_EXTRA_OK} otherwise.
 */
int32_t LLDISPLAY_EXTRA_isColor(void);

/**
 * Returns the number of colors the display can display.<br>
 * Usually the number of colors is <code>1 << BPP</code>, (BPP without transparency bits)
 * By default the weak function returns a value which follows this rule.
 * @return the number of colors the display can display.
 */
int32_t LLDISPLAY_EXTRA_getNumberOfColors(void);

/**
 * Asks if the display uses an underlying double buffer (either hardware or software).
 * This technique is useful to avoid flickering while the user is drawing.
 * @return true if and only if a double buffer is used for the display
 * @return {@link LLDISPLAY_EXTRA_OK} if and only if a double buffer is used for the display
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} otherwise. By default the weak function returns {@link LLDISPLAY_EXTRA_OK} 
 */
int32_t LLDISPLAY_EXTRA_isDoubleBuffered(void);

/**
 * Enters in a critical section of the display stack.<br>
 * <br>
 * Called by the framework in order to synchronize concurrent calls to the display
 * stack. Concurrent calls are the calls from the application using MicroUI API
 * and the calls from C-side using the <code>LLDISPLAY_UTILS</code> API.<br>
 * <br>
 * This function implementation can stay empty when there is no call from C-side 
 * or when the calls from C-side are performed in the same OS task than the 
 * MicroJVM Virtual Machine task.<br>
 * <br>
 * By default this function does nothing.
 */
void LLDISPLAY_EXTRA_enterDrawingMode(void);

/**
 * Exits from a critical section of the display stack.<br>
 * @see LLDISPLAY_EXTRA_enterDrawingMode
 */
void LLDISPLAY_EXTRA_exitDrawingMode(void);

/**
 * Called by display module when an error has occured. This error concerns only a wrong
 * implementation of a function of LLDISPLAY_IMPL.h or LLDISPLAY_EXTRA_IMPL.h. The available
 * list of error codes is described in MicroEJ SDK architecture documentation. 
 * @param errorCode
 */
void LLDISPLAY_EXTRA_error(int32_t errorCode);

/**
 * Fills the specified rectangle with the given color. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param image the image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param imageAddress the memory start address of the destination area
 * @param rectangle the rectangle to be filled represented by a <code>LLDISPLAY_SRectangle</code> structure
 * @param color the ARGB8888 color
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_fillRect(void* image, int32_t imageAddress, void* rectangle, int32_t color);

/**
 * Draws the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param drawing the foreground and destination data represented by a <code>LLDISPLAY_SDrawImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_drawImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* drawing);

/**
 * Draws the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation). The image will be flipped respecting the flip mode: with or without mirror effect
 * and then an anticlockwise rotation: 0, 90°, 180° or 270°.<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param flipping the foreground and destination data represented by a <code>LLDISPLAY_SFlipImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_flipImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* flipping);

/**
 * Draws with scaling the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param drawing the foreground and destination data represented by a <code>LLDISPLAY_SScaleImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_scaleImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* drawing);

/**
 * Draws with rotation the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param drawing the foreground and destination data represented by a <code>LLDISPLAY_SRotateImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_rotateImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* drawing);

/**
 * Called when the previous drawing ({@link LLDISPLAY_EXTRA_fillRect}
 * or {@link LLDISPLAY_EXTRA_drawImage} is asynchronous
 * (previous call has returned {@link LLDISPLAY_EXTRA_DRAWING_RUNNING}). 
 */
void LLDISPLAY_EXTRA_waitPreviousDrawing(void);

/**
 * Converts the 32-bit ARGB color format (A-R-G-B) into the display color format.<br>
 * <br>
 * This function is called only when the display is not a standard display: when
 * the pixel data does not match with one of these formats: {@link LLDISPLAY_EXTRA_IMAGE_ARGB8888},
 * {@link LLDISPLAY_EXTRA_IMAGE_RGB888}, {@link LLDISPLAY_EXTRA_IMAGE_RGB565}, {@link LLDISPLAY_EXTRA_IMAGE_ARGB1555} or 
 * {@link LLDISPLAY_EXTRA_IMAGE_ARGB4444}. In case of this function is not implemented whereas it is 
 * required, the result of pixel drawing is unknown.<br> 
 * <br>
 * Note: the alpha level may be ignored if the display pixel representation
 * does not hold the alpha level information.
 * @param color the color to convert
 * @return the converted color
 */
int32_t LLDISPLAY_EXTRA_convertARGBColorToDisplayColor(int32_t color);

/**
 * Converts the display color format into a 32-bit ARGB color format (A-R-G-B).<br>
 * <br>
 * This function is called only when the display is not a standard display: when
 * the pixel data does not match with one of these formats: {@link LLDISPLAY_EXTRA_IMAGE_ARGB8888},
 * {@link LLDISPLAY_EXTRA_IMAGE_RGB888}, {@link LLDISPLAY_EXTRA_IMAGE_RGB565}, {@link LLDISPLAY_EXTRA_IMAGE_ARGB1555} or 
 * {@link LLDISPLAY_EXTRA_IMAGE_ARGB4444}. In case of this function is not implemented whereas it is 
 * required, the result of pixel drawing is unknown.<br> 
 * <br>
 * Note: the alpha level may be ignored if the display pixel representation
 * does not hold the alpha level information.
 * @param color the color to convert
 * @return the converted color
 */
int32_t LLDISPLAY_EXTRA_convertDisplayColorToARGBColor(int32_t color);

/**
 * Prepare the blending of two ARGB colors. This is useful only when the LCD is a
 * palletized LCD. This function is called by framework when the MicroEJ application
 * draws something which requires a blending between the current foreground color and
 * a specific background color (draw a string, draw an anti-aliased line etc.). The
 * implementation has to replace the ARGB colors by the indexes of these colors in the
 * LCD CLUT. The framework will use the intermediate values between these two indexes
 * instead of blending in software the ARGB colors. No post conversion will be performed
 * later.<br>
 * <br>
 * When the ARGB colors are not available in the CLUT or when the range specified by the
 * two ARGB colors is not expected by the CLUT, the implementation should return
 * 0. In this way the blending will be done in software and the result
 * color will be converted later thanks a call to {@link #convertRGBColorToDisplayColor(int)}.<br>
 * <br>
 * By default the weak function returns 0 (feature not supported).
 * @param foreground pointer on the foreground ARGB color to convert
 * @param background pointer on the background ARGB color to convert
 * @return <code>OK</code> when the indexes have been found, <code>NOT_SUPPORTED</code> otherwise.
 */
int32_t LLDISPLAY_EXTRA_prepareBlendingOfIndexedColors(void* foreground, void* background);

/**
 * Use an hardware image decoder to create a RAW image. <br>
 * <br> 
 * The RAW image format is given by expectedFormat parameter. The decoder can choose another 
 * RAW image output format when it is not able to apply the expected format.<br>
 * <br>
 * The implementation has to fill the structure <code>LLDISPLAY_SDecoderImageData* data</code> with the image 
 * characteristics: its width, height, minimal row stride and the RAW image format.<br>
 * <br>
 * To allocate the RAW image pixels area, the implementation has to call the function 
 * <code>LLDISPLAY_UTILS_allocateDecoderImage()</code> (available in <code>LLDISPLAY_UTILS.h<c/ode>), 
 * giving the <code>LLDISPLAY_SDecoderImageData* rawData</code> parameter. This function will allocate 
 * the required memory area in the working buffer and fill this structure. <br>
 * <br>
 * The implementation returns {@link LLDISPLAY_EXTRA_OK} when the RAW image has been created. It has to return
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when the hardware decoder is not able to decode the given image. If the
 * function <code>LLDISPLAY_UTILS_allocateRawImage()</code> returns an error code, the implementation
 * has to return this error code immediately. 
 * @param addr the source image address
 * @param length the source image size in bytes
 * @param expectedFormat the RAW image expected format or {@link LLDISPLAY_EXTRA_IMAGE_DEFAULT} to let the implementation
 * choose the better output format
 * @param data the RAW image characteristics
 * @return an error code or {@link LLDISPLAY_EXTRA_OK}
 */
int32_t LLDISPLAY_EXTRA_decodeImage(int32_t addr, int32_t length, int32_t expectedFormat, void* data);

#ifdef __cplusplus
	}
#endif
#endif
