/* 
 * Copyright 2015-2019 MicroEJ Corp. All rights reserved.
 * MicroEJ Corp. PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/* 
 * AUTOGENERATED by Unknown product - Unknown version - DO NOT EDIT IT
 */
/* 
 * Implementation header file. Shall only be included by client implementation C files.
 */
#include <LLDISPLAY_EXTRA.h>
#include <stdint.h>
#include <intern/LLDISPLAY_EXTRA_impl.h>
// --------------------------------------------------------------------------------
// -                      Functions that must be implemented                      -
// --------------------------------------------------------------------------------

/**
 * The display graphics buffer may require more than memory than theorical memory.
 * Theorical memory size is <code>display width * display height * bpp / 8</code>. 
 * On some devices the memory width (in pixels) is higher than virtual width. 
 * In this way, the graphics buffer memory size is <code>memory width * height * bpp / 8</code>. 
 * This API allows to retrieve the memory width. Default behavior returns
 * display width.
 * @return the memory width (in pixels)
 */
int32_t LLDISPLAY_EXTRA_IMPL_getGraphicsBufferMemoryWidth(void);

/**
 * @see LLDISPLAY_EXTRA_getGraphicsBufferMemoryWidth
 * @return the memory height (in pixels)
 */
int32_t LLDISPLAY_EXTRA_IMPL_getGraphicsBufferMemoryHeight(void);

/**
 * Sets the new contrast. By default the weak function does nothing
 * (feature not supported).
 * @param contrast a value between <code>0</code> and <code>100</code>
 */
void LLDISPLAY_EXTRA_IMPL_setContrast(int32_t contrast);

/**
 * Gets the current contrast. By default the weak function returns
 * <code>0</code>.
 * @return a value between code>0</code> and <code>100</code>
 */
int32_t LLDISPLAY_EXTRA_IMPL_getContrast(void);

/**
 * Returns {@link LLDISPLAY_EXTRA_OK} when the display module can 
 * manage the display backlight or {@link LLDISPLAY_EXTRA_NOT_SUPPORTED}
 * otherwise. By default the weak function returns {@link LLDISPLAY_EXTRA_NOT_SUPPORTED}
 * (feature not supported).
 * @return {@link LLDISPLAY_EXTRA_OK} or {@link LLDISPLAY_EXTRA_NOT_SUPPORTED}
 */
int32_t LLDISPLAY_EXTRA_IMPL_hasBackLight(void);

/**
 * Sets the new backlight value. By default the weak function does nothing
 * (feature not supported).
 * @param backlight a value between code>0</code> and <code>100</code>
 */
void LLDISPLAY_EXTRA_IMPL_setBacklight(int32_t backLight);

/**
 * Gets the current backlight value. By default the weak function returns
 * <code>0</code>.
 * @return a value between code>0</code> and <code>100</code>
 */
int32_t LLDISPLAY_EXTRA_IMPL_getBacklight(void);

/**
 * Turns on the backlight. By default the weak function does nothing
 * (feature not supported).
 */
void LLDISPLAY_EXTRA_IMPL_backlightOn(void);

/**
 * Turns off the backlight. By default the weak function does nothing
 * (feature not supported).
 */
void LLDISPLAY_EXTRA_IMPL_backlightOff(void);

/**
 * Asks if the diplay is a colored display or not. 
 * @return {@link LLDISPLAY_EXTRA_OK} when the display is not a grayscale display, 
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} otherwise. By default the weak function returns
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when the BPP is lower than or equals to 4 BPP and 
 * {@link LLDISPLAY_EXTRA_OK} otherwise.
 */
int32_t LLDISPLAY_EXTRA_IMPL_isColor(void);

/**
 * Returns the number of colors the display can display.<br>
 * Usually the number of colors is <code>1 << BPP</code>, (BPP without transparency bits)
 * By default the weak function returns a value which follows this rule.
 * @return the number of colors the display can display.
 */
int32_t LLDISPLAY_EXTRA_IMPL_getNumberOfColors(void);

/**
 * Asks if the display uses an underlying double buffer (either hardware or software).
 * This technique is useful to avoid flickering while the user is drawing.
 * @return true if and only if a double buffer is used for the display
 * @return {@link LLDISPLAY_EXTRA_OK} if and only if a double buffer is used for the display
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} otherwise. By default the weak function returns {@link LLDISPLAY_EXTRA_OK} 
 */
int32_t LLDISPLAY_EXTRA_IMPL_isDoubleBuffered(void);

/**
 * Enters in a critical section of the display stack.<br>
 * <br>
 * Called by the framework in order to synchronize concurrent calls to the display
 * stack. Concurrent calls are the calls from the application using MicroUI API
 * and the calls from C-side using the <code>LLDISPLAY_UTILS</code> API.<br>
 * <br>
 * This function implementation can stay empty when there is no call from C-side 
 * or when the calls from C-side are performed in the same OS task than the 
 * MicroJVM Virtual Machine task.<br>
 * <br>
 * By default this function does nothing.
 */
void LLDISPLAY_EXTRA_IMPL_enterDrawingMode(void);

/**
 * Exits from a critical section of the display stack.<br>
 * @see LLDISPLAY_EXTRA_enterDrawingMode
 */
void LLDISPLAY_EXTRA_IMPL_exitDrawingMode(void);

/**
 * Called by display module when an error has occured. This error concerns only a wrong
 * implementation of a function of LLDISPLAY_IMPL.h or LLDISPLAY_EXTRA_IMPL.h. The available
 * list of error codes is described in MicroEJ SDK architecture documentation. 
 * @param errorCode
 */
void LLDISPLAY_EXTRA_IMPL_error(int32_t errorCode);

/**
 * Fills the specified rectangle with the given color. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param image the image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param imageAddress the memory start address of the destination area
 * @param rectangle the rectangle to be filled represented by a <code>LLDISPLAY_SRectangle</code> structure
 * @param color the ARGB8888 color
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_IMPL_fillRect(void* image, int32_t imageAddress, void* rectangle, int32_t color);

/**
 * Draws the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param drawing the foreground and destination data represented by a <code>LLDISPLAY_SDrawImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_IMPL_drawImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* drawing);

/**
 * Draws the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation). The image will be flipped respecting the flip mode: with or without mirror effect
 * and then an anticlockwise rotation: 0, 90°, 180° or 270°.<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param flipping the foreground and destination data represented by a <code>LLDISPLAY_SFlipImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_IMPL_flipImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* flipping);

/**
 * Draws with scaling the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param drawing the foreground and destination data represented by a <code>LLDISPLAY_SScaleImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_IMPL_scaleImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* drawing);

/**
 * Draws with rotation the source image content to the destination image. This function is called by display module when
 * a compatible display module extension has been selected in platform configuration project (see MicroEJ
 * SDK architecture documentation).<br>
 * @param srcHeader the image source characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param srcDataAddress the memory start address of the source image
 * @param destHeader image destination characteristics represented by a <code>LLDISPLAY_SImage</code> structure
 * @param destDataAddress the memory start address of the destination image
 * @param drawing the foreground and destination data represented by a <code>LLDISPLAY_SRotateImage</code> structure
 * @return {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when adaptation layer side is not able to
 * perform this drawing, {@link LLDISPLAY_EXTRA_DRAWING_COMPLETE} when the drawing has been fully
 * performed or {@link LLDISPLAY_EXTRA_DRAWING_RUNNING} when the asynchronous drawing has been started
 * and not fully performed yet. In this last case a call to {@link LLDISPLAY_EXTRA_waitPreviousDrawing} will 
 * be done before performing next drawing operation. 
 */
int32_t LLDISPLAY_EXTRA_IMPL_rotateImage(void* srcHeader, int32_t srcDataAddress, void* destHeader, int32_t destDataAddress, void* drawing);

/**
 * Called when the previous drawing ({@link LLDISPLAY_EXTRA_fillRect}
 * or {@link LLDISPLAY_EXTRA_drawImage} is asynchronous
 * (previous call has returned {@link LLDISPLAY_EXTRA_DRAWING_RUNNING}). 
 */
void LLDISPLAY_EXTRA_IMPL_waitPreviousDrawing(void);

/**
 * Converts the 32-bit ARGB color format (A-R-G-B) into the display color format.<br>
 * <br>
 * This function is called only when the display is not a standard display: when
 * the pixel data does not match with one of these formats: {@link LLDISPLAY_EXTRA_IMAGE_ARGB8888},
 * {@link LLDISPLAY_EXTRA_IMAGE_RGB888}, {@link LLDISPLAY_EXTRA_IMAGE_RGB565}, {@link LLDISPLAY_EXTRA_IMAGE_ARGB1555} or 
 * {@link LLDISPLAY_EXTRA_IMAGE_ARGB4444}. In case of this function is not implemented whereas it is 
 * required, the result of pixel drawing is unknown.<br> 
 * <br>
 * Note: the alpha level may be ignored if the display pixel representation
 * does not hold the alpha level information.
 * @param color the color to convert
 * @return the converted color
 */
int32_t LLDISPLAY_EXTRA_IMPL_convertARGBColorToDisplayColor(int32_t color);

/**
 * Converts the display color format into a 32-bit ARGB color format (A-R-G-B).<br>
 * <br>
 * This function is called only when the display is not a standard display: when
 * the pixel data does not match with one of these formats: {@link LLDISPLAY_EXTRA_IMAGE_ARGB8888},
 * {@link LLDISPLAY_EXTRA_IMAGE_RGB888}, {@link LLDISPLAY_EXTRA_IMAGE_RGB565}, {@link LLDISPLAY_EXTRA_IMAGE_ARGB1555} or 
 * {@link LLDISPLAY_EXTRA_IMAGE_ARGB4444}. In case of this function is not implemented whereas it is 
 * required, the result of pixel drawing is unknown.<br> 
 * <br>
 * Note: the alpha level may be ignored if the display pixel representation
 * does not hold the alpha level information.
 * @param color the color to convert
 * @return the converted color
 */
int32_t LLDISPLAY_EXTRA_IMPL_convertDisplayColorToARGBColor(int32_t color);

/**
 * Prepare the blending of two ARGB colors. This is useful only when the LCD is a
 * palletized LCD. This function is called by framework when the MicroEJ application
 * draws something which requires a blending between the current foreground color and
 * a specific background color (draw a string, draw an anti-aliased line etc.). The
 * implementation has to replace the ARGB colors by the indexes of these colors in the
 * LCD CLUT. The framework will use the intermediate values between these two indexes
 * instead of blending in software the ARGB colors. No post conversion will be performed
 * later.<br>
 * <br>
 * When the ARGB colors are not available in the CLUT or when the range specified by the
 * two ARGB colors is not expected by the CLUT, the implementation should return
 * 0. In this way the blending will be done in software and the result
 * color will be converted later thanks a call to {@link #convertRGBColorToDisplayColor(int)}.<br>
 * <br>
 * By default the weak function returns 0 (feature not supported).
 * @param foreground pointer on the foreground ARGB color to convert
 * @param background pointer on the background ARGB color to convert
 * @return <code>OK</code> when the indexes have been found, <code>NOT_SUPPORTED</code> otherwise.
 */
int32_t LLDISPLAY_EXTRA_IMPL_prepareBlendingOfIndexedColors(void* foreground, void* background);

/**
 * Use an hardware image decoder to create a RAW image. <br>
 * <br> 
 * The RAW image format is given by expectedFormat parameter. The decoder can choose another 
 * RAW image output format when it is not able to apply the expected format.<br>
 * <br>
 * The implementation has to fill the structure <code>LLDISPLAY_SDecoderImageData* data</code> with the image 
 * characteristics: its width, height, minimal row stride and the RAW image format.<br>
 * <br>
 * To allocate the RAW image pixels area, the implementation has to call the function 
 * <code>LLDISPLAY_UTILS_allocateDecoderImage()</code> (available in <code>LLDISPLAY_UTILS.h<c/ode>), 
 * giving the <code>LLDISPLAY_SDecoderImageData* rawData</code> parameter. This function will allocate 
 * the required memory area in the working buffer and fill this structure. <br>
 * <br>
 * The implementation returns {@link LLDISPLAY_EXTRA_OK} when the RAW image has been created. It has to return
 * {@link LLDISPLAY_EXTRA_NOT_SUPPORTED} when the hardware decoder is not able to decode the given image. If the
 * function <code>LLDISPLAY_UTILS_allocateRawImage()</code> returns an error code, the implementation
 * has to return this error code immediately. 
 * @param addr the source image address
 * @param length the source image size in bytes
 * @param expectedFormat the RAW image expected format or {@link LLDISPLAY_EXTRA_IMAGE_DEFAULT} to let the implementation
 * choose the better output format
 * @param data the RAW image characteristics
 * @return an error code or {@link LLDISPLAY_EXTRA_OK}
 */
int32_t LLDISPLAY_EXTRA_IMPL_decodeImage(int32_t addr, int32_t length, int32_t expectedFormat, void* data);
